<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ã‡ok KatlÄ± AR Navigasyon</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/jeromeetienne/AR.js/master/aframe/build/aframe-ar.min.js"></script>
    <script src="https://raw.githack.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
    <script>
        THREEx.ArToolkitContext.baseURL = 'https://raw.githack.com/jeromeetienne/ar.js/master/three.js/'
    </script>
    <script src="https://unpkg.com/@joeyklee/compass.js@latest/dist/compass.js"></script>
    <script src="https://kit.fontawesome.com/a076d05399.js"></script>
    <script src="./map-direction.js"></script>
    <link rel="stylesheet" type="text/css" href="./style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Portal GeÃ§iÅŸ Overlay */
        .portal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: white;
            text-align: center;
            padding: 20px;
        }
        .portal-overlay.hidden { display: none; }
        
        .portal-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 1s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        .portal-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .portal-subtitle {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 30px;
        }
        .portal-floors {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-bottom: 30px;
        }
        .portal-floor-badge {
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
        }
        .portal-floor-badge.from { background: #FF9800; }
        .portal-floor-badge.to { background: #4CAF50; }
        .portal-arrow { font-size: 30px; }
        
        .portal-confirm-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        .portal-confirm-btn:hover {
            background: #45a049;
        }
        
        
        /* ========== BOTTOM SHEET ========== */
        .bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #fff;
            border-radius: 20px 20px 0 0;
            box-shadow: 0 -4px 20px rgba(0,0,0,0.15);
            z-index: 5000;
            padding: 16px 20px 24px 20px;
        }
        
        .bottom-sheet-handle {
            width: 40px;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            margin: 0 auto 16px auto;
        }
        
        .bottom-sheet-content {
            position: relative;
            min-height: 50px;
        }
        
        .bottom-sheet-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .bottom-sheet-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            background: #f5f5f5;
            border: 1px solid #eee;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .bottom-sheet-icon img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .bottom-sheet-text h3 {
            margin: 0 0 4px 0;
            font-size: 16px;
            font-weight: 600;
            color: #222;
        }
        
        .bottom-sheet-text p {
            margin: 0;
            font-size: 14px;
            color: #666;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .bottom-sheet-text p i {
            font-size: 12px;
            color: #888;
        }
        
        .bottom-sheet-btn {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: #4CAF50;
            color: #fff;
            border: none;
            padding: 18px 24px;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }
        
        .bottom-sheet-btn:hover {
            background: #43A047;
        }
        
        .bottom-sheet-btn:active {
            background: #388E3C;
        }
        
        .bottom-sheet-btn.hidden {
            display: none;
        }
        
        .bottom-sheet-btn i {
            font-size: 14px;
        }
    </style>
</head>

<body style='margin: 0; overflow: hidden;'>


    <!-- Portal GeÃ§iÅŸ Overlay -->
    <div class="portal-overlay hidden" id="portalOverlay">
        <div class="portal-icon" id="portalIcon">ðŸ›—</div>
        <div class="portal-title" id="portalTitle">AsansÃ¶r ile Kat DeÄŸiÅŸtirin</div>
        <div class="portal-subtitle" id="portalSubtitle">AsansÃ¶r 3 kullanarak aÅŸaÄŸÄ± inin</div>
        <div class="portal-floors">
            <div class="portal-floor-badge from" id="portalFromFloor">Kat 0</div>
            <div class="portal-arrow">â†’</div>
            <div class="portal-floor-badge to" id="portalToFloor">Kat -1</div>
        </div>
        <button class="portal-confirm-btn" id="portalConfirmBtn">
            <i class="fas fa-check"></i> Kata UlaÅŸtÄ±m
        </button>
    </div>

    <div class="arrow left" id="left-arrow">
        <img src="assets/left_arrow.png" alt="Left Arrow" class="arrow-icon left-arrow">
    </div>
    <div class="arrow right" id="right-arrow">
        <img src="assets/right_arrow.png" alt="Right Arrow" class="arrow-icon right-arrow">
    </div>
    <div class="arrow up" id="up-arrow">
        <img src="assets/ileri.png" alt="Up Arrow" class="arrow-icon up-arrow">
    </div>
    <div class="arrow up-perspective" id="up-arrow-perspective">
        <img src="assets/arrow-up.png" alt="Up Arrow Perspective" class="arrow-icon up-arrow-perspective">
    </div>
    
    <div class="container">
        <svg class="progress-circle" width="200" height="200" viewBox="0 0 100 100" id="circle-svg">
            <circle cx="50" cy="50" r="45" fill="none" stroke="lightgray" stroke-width="5" />
            <circle class="progress" cx="50" cy="50" r="45" fill="white" fill-opacity="0.1" stroke="white"
                stroke-width="5" stroke-dasharray="283" stroke-dashoffset="283" />
        </svg>
    </div>


    <div class="bottom-container">
        <div class="map-section" id="mapSection">
            <div id="svgContainer" style="width: 100%; height: 100%; overflow: hidden; position: relative;">
                <div id="svgWrapper" style="transform-origin: 0 0; cursor: grab;">
                    <!-- SVG buraya yÃ¼klenecek -->
                </div>
            </div>
        </div>
        <div class="button-section">
            <button class="center-button">
                <img src="assets/cube_white.png" alt="Cube Icon" />
                View In AR
            </button>
            <button class="right-button">Stop</button>
        </div>

    </div>
    
    <!-- BOTTOM SHEET -->
    <div class="bottom-sheet">
        <div class="bottom-sheet-handle"></div>
        <div class="bottom-sheet-content">
            <div class="bottom-sheet-info">
                <div class="bottom-sheet-icon">
                    <img src="https://i.ibb.co/PjjtDkp/inmapper-1.png" alt="Icon" />
                </div>
                <div class="bottom-sheet-text">
                    <h3 id="destinationName">Hedef YÃ¶n</h3>
                    <p><i class="fa-solid fa-person-running"></i> <span id="directionText">YÃ¼kleniyor...</span></p>
                </div>
            </div>
            <button class="bottom-sheet-btn" id="nextStepBtn">
                Sonraki <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>

    <div class="popup" id="popup">
        <div class="popup-content">
            <a href="https://imgbb.com/">
                <img src="assets/location.gif" alt="location" class="popup-image">
            </a>
            <div class="popup-message" id="popupMessage">YÃ¶n tamamlandÄ±!</div><br>
            <div class="popup-button-container">
                <button class="btn-ok" id="popupOkBtn">
                    <i class="fas fa-check"></i>
                    <span id="popupBtnText">Tamam</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // ==================== GLOBAL STATE ====================
        let mapDirection = null;
        let routeData = null;
        let currentSegmentIndex = 0;
        let currentDirection = null;
        let directionToTurn = 0;
        
        let svgElement = null;
        let scale = 1;
        let panX = 0, panY = 0;
        let isPanning = false;
        let startPanX, startPanY;
        
        let directionMatches = false;
        let isLoading = false;
        let activeAScene = null;
        let compassListeners = { absolute: null, webkit: null };

        // ==================== URL PARAMS ====================
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                routeData: params.get('routeData'),
                startRoom: params.get('startRoom') || '',
                endRoom: params.get('endRoom') || '',
                startFloor: params.get('startFloor') || '0',
                endFloor: params.get('endFloor') || '0',
                // Eski tek-kat uyumluluk
                angle: parseFloat(params.get('angle')) || 0,
                compass: params.get('compass') || 'Kuzey',
                startX: parseFloat(params.get('startX')) || 0,
                startY: parseFloat(params.get('startY')) || 0,
                dirX: parseFloat(params.get('dirX')) || 0,
                dirY: parseFloat(params.get('dirY')) || 1
            };
        }
        
        const targetParams = getQueryParams();

        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', async function() {
            mapDirection = new MapDirection();
            
            // Rota verilerini parse et
            if (targetParams.routeData) {
                try {
                    routeData = JSON.parse(decodeURIComponent(targetParams.routeData));
                    console.log('Rota yÃ¼klendi:', routeData);
                    
                    // Ã‡oklu kat modunda baÅŸlat
                    await initMultiFloorMode();
                } catch (e) {
                    console.error('Rota parse hatasÄ±:', e);
                    // Eski moda geri dÃ¶n
                    initSingleFloorMode();
                }
            } else {
                // Eski tek-kat modu
                initSingleFloorMode();
            }
            
            setupEventListeners();
        });

        // ==================== SINGLE FLOOR MODE (Backward Compatible) ====================
        function initSingleFloorMode() {
            console.log('Tek kat modu');
            directionToTurn = targetParams.angle;
            
            document.getElementById('directionText').textContent = targetParams.compass + ' yÃ¶nÃ¼ne dÃ¶nÃ¼n';
            
            // Sonraki adÄ±m butonunu gizle (tek kat modunda kullanÄ±lmaz)
            document.getElementById('nextStepBtn').classList.add('hidden');
            
            loadSVGOld();
        }

        // ==================== MULTI FLOOR MODE ====================
        async function initMultiFloorMode() {
            console.log('Ã‡ok kat modu');
            
            // TÃ¼m katlarÄ± yÃ¼kle
            await mapDirection.loadAllFloors('./zorlu');
            
            // Ä°lk segment ile baÅŸla
            currentSegmentIndex = 0;
            
            // Segment UI'Ä± gÃ¼ncelle
            updateSegmentUI();
            
            // Ä°lk segmenti baÅŸlat
            startCurrentSegment();
        }
        
        let arButtonTimer = null; // AR butonu zamanlayÄ±cÄ±sÄ±
        
        function updateSegmentUI() {
            if (!routeData || !routeData.segments) return;
            
            const segments = routeData.segments;
            const nextStepBtn = document.getElementById('nextStepBtn');
            const destinationName = document.getElementById('destinationName');
            const directionText = document.getElementById('directionText');
            
            // Segment bilgisini gÃ¼ncelle
            const currentSeg = segments[currentSegmentIndex];
            const routeSegments = segments.filter(s => s.type !== 'portal_transition');
            const currentRouteIndex = segments.slice(0, currentSegmentIndex + 1).filter(s => s.type !== 'portal_transition').length;
            
            if (currentSeg) {
                if (currentSeg.type === 'portal_transition') {
                    destinationName.textContent = `Kat ${currentSeg.floor} â†’ ${currentSeg.toFloor}`;
                } else {
                    destinationName.textContent = `Kat ${currentSeg.floor} (${currentRouteIndex}/${routeSegments.length})`;
                }
            }
            
            // Sonraki adÄ±m butonunu gÃ¶ster/gizle
            const isLastSegment = currentSegmentIndex >= segments.length - 1;
            const isPortalTransition = currentSeg?.type === 'portal_transition';
            
            if (!isLastSegment && !isPortalTransition) {
                nextStepBtn.classList.remove('hidden');
            } else {
                nextStepBtn.classList.add('hidden');
            }
            
            // AR butonunu gÃ¶ster ve zamanlayÄ±cÄ± baÅŸlat
            showARButtonWithTimer();
        }
        
        function showARButtonWithTimer() {
            const centerButton = document.querySelector('.center-button');
            const bottomContainer = document.querySelector('.bottom-container');
            
            // Ã–nceki zamanlayÄ±cÄ±yÄ± temizle
            if (arButtonTimer) {
                clearTimeout(arButtonTimer);
                arButtonTimer = null;
            }
            
            // Butonu gÃ¶ster
            centerButton.style.display = 'block';
            bottomContainer.style.height = '100%';
            
            // 10 saniye sonra gizle
            arButtonTimer = setTimeout(() => {
                centerButton.style.display = 'none';
                console.log('AR butonu 10 saniye sonra gizlendi');
            }, 10000);
        }
        
        function startCurrentSegment() {
            if (!routeData || !routeData.segments) return;
            
            const segment = routeData.segments[currentSegmentIndex];
            if (!segment) {
                console.log('TÃ¼m segmentler tamamlandÄ±!');
                showFinalPopup();
                return;
            }
            
            console.log(`Segment ${currentSegmentIndex + 1} baÅŸlÄ±yor:`, segment);
            
            if (segment.type === 'portal_transition') {
                // Portal geÃ§iÅŸini atla, doÄŸrudan sonraki segmente geÃ§
                console.log('Portal geÃ§iÅŸi atlanÄ±yor:', segment.description);
                goToNextSegment();
            } else {
                // Normal rota segmenti
                startRouteSegment(segment);
            }
        }
        
        function startRouteSegment(segment) {
            // Kat deÄŸiÅŸtir
            mapDirection.setCurrentFloor(segment.floor);
            
            // Direction bilgisini al
            currentDirection = segment.direction;
            
            if (currentDirection) {
                directionToTurn = currentDirection.compassAngle;
                document.getElementById('directionText').textContent = currentDirection.compass + ' yÃ¶nÃ¼ne dÃ¶nÃ¼n';
                document.getElementById('destinationName').textContent = `Kat ${segment.floor}`;
            } else {
                console.warn('Direction bulunamadÄ±, segment:', segment);
            }
            
            // SVG'yi yÃ¼kle
            loadFloorSVG(segment.floor, segment);
            
            // Segment UI gÃ¼ncelle
            updateSegmentUI();
        }
        
        function showPortalOverlay(segment) {
            const overlay = document.getElementById('portalOverlay');
            const icon = document.getElementById('portalIcon');
            const title = document.getElementById('portalTitle');
            const subtitle = document.getElementById('portalSubtitle');
            const fromFloor = document.getElementById('portalFromFloor');
            const toFloor = document.getElementById('portalToFloor');
            
            const portal = segment.portal;
            const isElevator = portal?.portalType === 'Elev';
            
            icon.textContent = isElevator ? 'ðŸ›—' : 'ðŸš¶';
            title.textContent = isElevator ? 'AsansÃ¶r ile Kat DeÄŸiÅŸtirin' : 'Merdiven ile Kat DeÄŸiÅŸtirin';
            subtitle.textContent = `${isElevator ? 'AsansÃ¶r' : 'Merdiven'} ${portal?.portalNumber || ''} kullanÄ±n`;
            fromFloor.textContent = `Kat ${segment.floor}`;
            toFloor.textContent = `Kat ${segment.toFloor}`;
            
            overlay.classList.remove('hidden');
            
            // AR'Ä± durdur
            stopARAndCleanup();
        }
        
        function hidePortalOverlay() {
            document.getElementById('portalOverlay').classList.add('hidden');
        }
        
        function goToNextSegment() {
            currentSegmentIndex++;
            updateSegmentUI();
            startCurrentSegment();
        }
        
        function showFinalPopup() {
            const popup = document.getElementById('popup');
            const message = document.getElementById('popupMessage');
            const btnText = document.getElementById('popupBtnText');
            
            message.textContent = `ðŸŽ‰ Hedefinize ulaÅŸtÄ±nÄ±z! (${targetParams.endRoom})`;
            btnText.textContent = 'BaÅŸa DÃ¶n';
            
            popup.style.display = 'block';
        }
        
        // ==================== SVG LOADING ====================
        async function loadFloorSVG(floorId, segment) {
            try {
                const response = await fetch(`./zorlu/${floorId}.svg`);
                if (!response.ok) throw new Error(`SVG yÃ¼klenemedi: ${floorId}`);
                
                const content = await response.text();
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'image/svg+xml');
                svgElement = doc.documentElement.cloneNode(true);
                
                svgElement.style.width = '100%';
                svgElement.style.height = '100%';
                svgElement.removeAttribute('width');
                svgElement.removeAttribute('height');
                svgElement.setAttribute('viewBox', '-20 -20 700 850');
                
                const wrapper = document.getElementById('svgWrapper');
                wrapper.innerHTML = '';
                wrapper.appendChild(svgElement);
                
                // Segment'e gÃ¶re yÃ¶n okunu ve path'i Ã§iz
                if (segment && segment.direction) {
                    drawDirectionArrowMulti(segment);
                    highlightSegmentPath(segment);
                }
                
                // BaÅŸlangÄ±Ã§ noktasÄ±na odaklan
                if (segment && segment.direction && segment.direction.startPoint) {
                    centerOnPoint(segment.direction.startPoint[0], segment.direction.startPoint[1]);
                }
                
                setupZoomPan();
                console.log(`Kat ${floorId} SVG yÃ¼klendi`);
            } catch (e) {
                console.error('SVG yÃ¼klenemedi:', e);
            }
        }
        
        // Eski tek-kat SVG yÃ¼kleyici
        async function loadSVGOld() {
            try {
                let response = await fetch('./zorlu/0.svg');
                if (!response.ok) {
                    response = await fetch('./sample.svg');
                }
                if (response.ok) {
                    const content = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(content, 'image/svg+xml');
                    svgElement = doc.documentElement.cloneNode(true);
                    
                    svgElement.style.width = '100%';
                    svgElement.style.height = '100%';
                    svgElement.removeAttribute('width');
                    svgElement.removeAttribute('height');
                    svgElement.setAttribute('viewBox', '-20 -20 700 850');
                    
                    const wrapper = document.getElementById('svgWrapper');
                    wrapper.appendChild(svgElement);
                    
                    drawDirectionArrow();
                    highlightUsedPaths();
                    centerOnPoint(targetParams.startX, targetParams.startY);
                    setupZoomPan();
                }
            } catch (e) {
                console.error('SVG yÃ¼klenemedi:', e);
            }
        }
        
        // ==================== DRAWING FUNCTIONS ====================
        function drawDirectionArrowMulti(segment) {
            if (!svgElement || !segment.direction) return;
            
            const ns = 'http://www.w3.org/2000/svg';
            const direction = segment.direction;
            
            const oldArrow = svgElement.querySelector('#direction-arrow-group');
            if (oldArrow) oldArrow.remove();
            
            const roomsGroup = svgElement.querySelector('g[id="Rooms"]') || 
                               svgElement.querySelector('g[inkscape\\:label="Rooms"]');
            let groupTransform = roomsGroup ? (roomsGroup.getAttribute('transform') || '') : '';
            
            const group = document.createElementNS(ns, 'g');
            group.setAttribute('id', 'direction-arrow-group');
            if (groupTransform) group.setAttribute('transform', groupTransform);
            
            const startX = direction.startPoint[0];
            const startY = direction.startPoint[1];
            const arrowLength = 35;
            const endX = startX + direction.directionVector[0] * arrowLength;
            const endY = startY + direction.directionVector[1] * arrowLength;
            
            // Ok Ã§izgisi
            const line = document.createElementNS(ns, 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#00CC00');
            line.setAttribute('stroke-width', '3');
            line.setAttribute('stroke-linecap', 'round');
            group.appendChild(line);
            
            // Ok ucu
            const angle = Math.atan2(direction.directionVector[1], direction.directionVector[0]);
            const headLen = 10;
            const headAngle = Math.PI / 6;
            
            const hx1 = endX - headLen * Math.cos(angle - headAngle);
            const hy1 = endY - headLen * Math.sin(angle - headAngle);
            const hx2 = endX - headLen * Math.cos(angle + headAngle);
            const hy2 = endY - headLen * Math.sin(angle + headAngle);
            
            const head = document.createElementNS(ns, 'polygon');
            head.setAttribute('points', `${endX},${endY} ${hx1},${hy1} ${hx2},${hy2}`);
            head.setAttribute('fill', '#00CC00');
            group.appendChild(head);
            
            // BaÅŸlangÄ±Ã§ noktasÄ±
            const circle = document.createElementNS(ns, 'circle');
            circle.setAttribute('cx', startX);
            circle.setAttribute('cy', startY);
            circle.setAttribute('r', '5');
            circle.setAttribute('fill', '#FF3333');
            circle.setAttribute('stroke', '#FFFFFF');
            circle.setAttribute('stroke-width', '2');
            group.appendChild(circle);
            
            // Portal hedefi varsa iÅŸaretle
            if (segment.toPortal) {
                const portalCircle = document.createElementNS(ns, 'circle');
                portalCircle.setAttribute('cx', segment.toPortal.center[0]);
                portalCircle.setAttribute('cy', segment.toPortal.center[1]);
                portalCircle.setAttribute('r', '8');
                portalCircle.setAttribute('fill', '#FF9800');
                portalCircle.setAttribute('stroke', '#FFFFFF');
                portalCircle.setAttribute('stroke-width', '2');
                group.appendChild(portalCircle);
                
                // Portal ikonu (text)
                const portalText = document.createElementNS(ns, 'text');
                portalText.setAttribute('x', segment.toPortal.center[0]);
                portalText.setAttribute('y', segment.toPortal.center[1] + 4);
                portalText.setAttribute('text-anchor', 'middle');
                portalText.setAttribute('font-size', '10');
                portalText.setAttribute('fill', 'white');
                portalText.textContent = segment.toPortal.portalType === 'Elev' ? 'ðŸ›—' : 'ðŸš¶';
                group.appendChild(portalText);
            }
            
            svgElement.appendChild(group);
        }
        
        function highlightSegmentPath(segment) {
            if (!svgElement || !segment.direction) return;
            
            // DoÄŸru katÄ±n path'lerini kullan
            mapDirection.setCurrentFloor(segment.floor);
            console.log(`Path highlight iÃ§in kat ayarlandÄ±: ${segment.floor}, ${mapDirection.paths?.length || 0} path`);
            
            const ns = 'http://www.w3.org/2000/svg';
            const direction = segment.direction;
            
            const roomsGroup = svgElement.querySelector('g[id="Rooms"]');
            let groupTransform = roomsGroup ? (roomsGroup.getAttribute('transform') || '') : '';
            
            const highlightGroup = document.createElementNS(ns, 'g');
            highlightGroup.setAttribute('id', 'path-highlight-group');
            if (groupTransform) highlightGroup.setAttribute('transform', groupTransform);
            
            // Path'i bulmak iÃ§in baÅŸlangÄ±Ã§ ve hedef noktalarÄ±nÄ± kullan
            const startPoint = direction.startPoint;
            const endPoint = direction.endPoint;
            
            if (startPoint && endPoint) {
                console.log(`Path aranÄ±yor: [${startPoint}] -> [${endPoint}]`);
                const pathResult = mapDirection.findPathBetweenPoints(startPoint, endPoint);
                console.log(`Path sonucu: ${pathResult ? pathResult.length + ' nokta' : 'null'}`);
                
                if (pathResult && pathResult.length >= 2) {
                    const fullPath = [startPoint, ...pathResult];
                    console.log(`Ã‡izilecek path: ${fullPath.length} nokta`);
                    
                    for (let i = 0; i < fullPath.length - 1; i++) {
                        const p1 = fullPath[i];
                        const p2 = fullPath[i + 1];
                        
                        const line = document.createElementNS(ns, 'line');
                        line.setAttribute('x1', p1[0]);
                        line.setAttribute('y1', p1[1]);
                        line.setAttribute('x2', p2[0]);
                        line.setAttribute('y2', p2[1]);
                        
                        if (i < 5) {
                            line.setAttribute('stroke', '#FF6600');
                            line.setAttribute('stroke-width', '3');
                            line.setAttribute('opacity', '0.9');
                        } else {
                            line.setAttribute('stroke', '#0066ff');
                            line.setAttribute('stroke-width', '2');
                            line.setAttribute('opacity', '0.5');
                        }
                        line.setAttribute('stroke-linecap', 'round');
                        highlightGroup.appendChild(line);
                    }
                } else {
                    console.warn(`Path bulunamadÄ±, fallback Ã§izgi Ã§iziliyor`);
                    // Fallback: doÄŸrudan Ã§izgi Ã§iz
                    const line = document.createElementNS(ns, 'line');
                    line.setAttribute('x1', startPoint[0]);
                    line.setAttribute('y1', startPoint[1]);
                    line.setAttribute('x2', endPoint[0]);
                    line.setAttribute('y2', endPoint[1]);
                    line.setAttribute('stroke', '#ff0000');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('stroke-dasharray', '5,5');
                    line.setAttribute('opacity', '0.8');
                    highlightGroup.appendChild(line);
                }
            }
            
            svgElement.appendChild(highlightGroup);
        }
        
        // Eski tek-kat fonksiyonlarÄ± (geriye uyumluluk)
        function drawDirectionArrow() {
            if (!svgElement) return;
            
            const ns = 'http://www.w3.org/2000/svg';
            
            const oldArrow = svgElement.querySelector('#direction-arrow-group');
            if (oldArrow) oldArrow.remove();
            
            const roomsGroup = svgElement.querySelector('g[id="Rooms"]');
            let groupTransform = roomsGroup ? (roomsGroup.getAttribute('transform') || '') : '';
            
            const group = document.createElementNS(ns, 'g');
            group.setAttribute('id', 'direction-arrow-group');
            if (groupTransform) group.setAttribute('transform', groupTransform);
            
            const startX = targetParams.startX;
            const startY = targetParams.startY;
            const arrowLength = 35;
            const endX = startX + targetParams.dirX * arrowLength;
            const endY = startY + targetParams.dirY * arrowLength;
            
            const line = document.createElementNS(ns, 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#00CC00');
            line.setAttribute('stroke-width', '3');
            line.setAttribute('stroke-linecap', 'round');
            group.appendChild(line);
            
            const angle = Math.atan2(targetParams.dirY, targetParams.dirX);
            const headLen = 10;
            const headAngle = Math.PI / 6;
            
            const hx1 = endX - headLen * Math.cos(angle - headAngle);
            const hy1 = endY - headLen * Math.sin(angle - headAngle);
            const hx2 = endX - headLen * Math.cos(angle + headAngle);
            const hy2 = endY - headLen * Math.sin(angle + headAngle);
            
            const head = document.createElementNS(ns, 'polygon');
            head.setAttribute('points', `${endX},${endY} ${hx1},${hy1} ${hx2},${hy2}`);
            head.setAttribute('fill', '#00CC00');
            group.appendChild(head);
            
            const circle = document.createElementNS(ns, 'circle');
            circle.setAttribute('cx', startX);
            circle.setAttribute('cy', startY);
            circle.setAttribute('r', '5');
            circle.setAttribute('fill', '#FF3333');
            circle.setAttribute('stroke', '#FFFFFF');
            circle.setAttribute('stroke-width', '2');
            group.appendChild(circle);
            
            svgElement.appendChild(group);
        }
        
        async function highlightUsedPaths() {
            // Eski fonksiyon - artÄ±k kullanÄ±lmÄ±yor
        }
        
        // ==================== ZOOM/PAN ====================
        function centerOnPoint(x, y) {
            const container = document.getElementById('svgContainer');
            if (!svgElement) return;
            
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            const svgRect = svgElement.getBoundingClientRect();
            
            const translateX = -155.17664;
            const translateY = -527.47596;
            
            const transformedX = x + translateX;
            const transformedY = y + translateY;
            
            scale = 0.8;
            
            const vbX = -20, vbY = -20, vbWidth = 700, vbHeight = 850;
            const svgScale = Math.min(svgRect.width / vbWidth, svgRect.height / vbHeight);
            const pointX = (transformedX - vbX) * svgScale * scale;
            const pointY = (transformedY - vbY) * svgScale * scale;
            
            panX = containerWidth / 2 - pointX;
            panY = containerHeight / 2 - pointY;
            
            updateTransform();
        }
        
        function updateTransform() {
            const wrapper = document.getElementById('svgWrapper');
            wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        }
        
        function setupZoomPan() {
            const container = document.getElementById('svgContainer');
            
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                const newScale = scale * delta;
                if (newScale < 0.1 || newScale > 10) return;
                
                panX = mouseX - (mouseX - panX) * delta;
                panY = mouseY - (mouseY - panY) * delta;
                scale = newScale;
                
                updateTransform();
            });
            
            container.addEventListener('mousedown', (e) => {
                isPanning = true;
                startPanX = e.clientX - panX;
                startPanY = e.clientY - panY;
                container.style.cursor = 'grabbing';
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                panX = e.clientX - startPanX;
                panY = e.clientY - startPanY;
                updateTransform();
            });
            
            container.addEventListener('mouseup', () => {
                isPanning = false;
                container.style.cursor = 'grab';
            });
            
            container.addEventListener('mouseleave', () => {
                isPanning = false;
                container.style.cursor = 'grab';
            });
            
            // Touch support
            let lastTouchDist = 0;
            
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isPanning = true;
                    startPanX = e.touches[0].clientX - panX;
                    startPanY = e.touches[0].clientY - panY;
                } else if (e.touches.length === 2) {
                    lastTouchDist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            });
            
            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && isPanning) {
                    panX = e.touches[0].clientX - startPanX;
                    panY = e.touches[0].clientY - startPanY;
                    updateTransform();
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    scale *= dist / lastTouchDist;
                    if (scale < 0.1) scale = 0.1;
                    if (scale > 10) scale = 10;
                    lastTouchDist = dist;
                    updateTransform();
                }
            });
            
            container.addEventListener('touchend', () => {
                isPanning = false;
            });
        }

        // ==================== EVENT LISTENERS ====================
        function setupEventListeners() {
            const centerButton = document.querySelector('.center-button');
            const rightButton = document.querySelector('.right-button');
            const okButton = document.getElementById('popupOkBtn');
            const portalConfirmBtn = document.getElementById('portalConfirmBtn');
            const nextStepBtn = document.getElementById('nextStepBtn');
            const bottomContainer = document.querySelector('.bottom-container');
            const popup = document.getElementById('popup');

            centerButton.addEventListener('click', function () {
                // AR butonu zamanlayÄ±cÄ±sÄ±nÄ± durdur
                if (arButtonTimer) {
                    clearTimeout(arButtonTimer);
                    arButtonTimer = null;
                }
                
                activeAScene = document.createElement('a-scene');
                activeAScene.setAttribute('vr-mode-ui', 'enabled: false');
                activeAScene.style.position = 'absolute';
                activeAScene.style.top = '0';
                activeAScene.style.left = '0';
                activeAScene.style.width = '100%';
                activeAScene.style.height = '100%';
                activeAScene.style.zIndex = '1';
                document.body.appendChild(activeAScene);
                bottomContainer.style.height = '40%';
                centerButton.style.display = 'none';
                rightButton.style.display = 'block';
                
                // Sonraki adÄ±m butonunu gizle (AR modunda)
                nextStepBtn.classList.add('hidden');
                
                startCompassListener((compass, beta) => {
                    showArrow(directionToTurn, compass, beta);
                });
            });

            rightButton.addEventListener('click', function () {
                stopARAndCleanup();
                bottomContainer.style.height = '100%';
                rightButton.style.display = 'none';
                
                // AR butonunu zamanlayÄ±cÄ± ile tekrar gÃ¶ster
                showARButtonWithTimer();
                
                // Sonraki adÄ±m butonunu gÃ¶ster
                updateSegmentUI();
            });

            okButton.addEventListener('click', function () {
                popup.style.display = 'none';
                
                // Ã‡oklu kat modunda sonraki segmente geÃ§
                if (routeData && routeData.segments) {
                    if (currentSegmentIndex < routeData.segments.length - 1) {
                        goToNextSegment();
                    } else {
                        // TÃ¼m rotalar tamamlandÄ±, ana sayfaya dÃ¶n
                        window.location.href = 'index.html';
                    }
                } else {
                    stopARAndCleanup();
                    bottomContainer.style.height = '100%';
                }
            });
            
            // Sonraki adÄ±m butonu
            nextStepBtn.addEventListener('click', function() {
                if (routeData && routeData.segments && currentSegmentIndex < routeData.segments.length - 1) {
                    goToNextSegment();
                }
            });
            
            // Portal onay butonu
            portalConfirmBtn.addEventListener('click', function() {
                hidePortalOverlay();
                goToNextSegment();
                
                // AR butonunu gÃ¶ster
                const bottomContainer = document.querySelector('.bottom-container');
                const centerButton = document.querySelector('.center-button');
                bottomContainer.style.height = '100%';
                centerButton.style.display = 'block';
            });
        }
        
        // ==================== AR FUNCTIONS ====================
        function stopARAndCleanup() {
            if (compassListeners.absolute) {
                window.removeEventListener("deviceorientationabsolute", compassListeners.absolute);
                compassListeners.absolute = null;
            }
            if (compassListeners.webkit) {
                window.removeEventListener("deviceorientation", compassListeners.webkit);
                compassListeners.webkit = null;
            }
            
            stopAllCameraStreams();
            
            if (activeAScene) {
                activeAScene.remove();
                activeAScene = null;
            }
            
            document.querySelectorAll('a-scene').forEach(scene => scene.remove());
            
            const progressCircle = document.querySelector('.progress');
            if (progressCircle) {
                progressCircle.style.strokeDashoffset = '283';
            }
            
            const container = document.querySelector('.container');
            if (container) {
                container.classList.remove('grow');
            }
            
            hideAllArrows();
        }
        
        function stopAllCameraStreams() {
            document.querySelectorAll('video').forEach(video => {
                if (video.srcObject) {
                    video.srcObject.getTracks().forEach(track => track.stop());
                    video.srcObject = null;
                }
                video.pause();
                video.remove();
            });
        }
        
        function hideAllArrows() {
            const arrows = ['left-arrow', 'right-arrow', 'up-arrow', 'up-arrow-perspective'];
            arrows.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.remove('fade-in');
            });
        }

        function showArrow(directionToTurn, direction, beta) {
            const arScene = document.querySelector('a-scene');
            if (!arScene) return;
            
            const leftArrow = document.getElementById('left-arrow');
            const rightArrow = document.getElementById('right-arrow');
            const upArrow = document.getElementById('up-arrow');
            const upPerspectiveArrow = document.getElementById('up-arrow-perspective');
            const popup = document.querySelector('.popup');
            const container = document.querySelector('.container');
            const progressCircle = document.querySelector('.progress');

            leftArrow.classList.remove('fade-in', 'fade-out');
            rightArrow.classList.remove('fade-in', 'fade-out');
            upArrow.classList.remove('fade-in', 'fade-out');
            upPerspectiveArrow.classList.remove('fade-in', 'fade-out');

            const upperBound = (directionToTurn + 20) % 360;
            const lowerBound = (directionToTurn - 20 + 360) % 360;

            if ((direction <= upperBound && direction >= lowerBound) ||
                (lowerBound > upperBound && (direction >= lowerBound || direction <= upperBound))) {

                if (beta < 30) {
                    upPerspectiveArrow.classList.add('fade-in');
                    upArrow.classList.remove('fade-in');
                } else {
                    upArrow.classList.add('fade-in');
                    upPerspectiveArrow.classList.remove('fade-in');
                }
                leftArrow.classList.add('fade-out');
                rightArrow.classList.add('fade-out');
                directionMatches = true;
                container.classList.add('grow');
                isLoading = true;
                progressCircle.style.strokeDashoffset = '0';

                const monitorAnimation = () => {
                    const currentOffset = parseFloat(getComputedStyle(progressCircle).strokeDashoffset);

                    if (currentOffset === 0) {
                        console.log('Segment tamamlandÄ±!');
                        
                        stopAllCameraStreams();
                        
                        if (compassListeners.absolute) {
                            window.removeEventListener("deviceorientationabsolute", compassListeners.absolute);
                            compassListeners.absolute = null;
                        }
                        if (compassListeners.webkit) {
                            window.removeEventListener("deviceorientation", compassListeners.webkit);
                            compassListeners.webkit = null;
                        }
                        
                        if (activeAScene) {
                            activeAScene.remove();
                            activeAScene = null;
                        }
                        document.querySelectorAll('a-scene').forEach(scene => scene.remove());
                        
                        hideAllArrows();
                        
                        // Ã‡oklu kat modunda sonraki segmente geÃ§
                        if (routeData && routeData.segments && currentSegmentIndex < routeData.segments.length - 1) {
                            // Sonraki segment portal mÄ±?
                            const nextSegment = routeData.segments[currentSegmentIndex + 1];
                            if (nextSegment && nextSegment.type === 'portal_transition') {
                                goToNextSegment();
                            } else {
                                // Normal segment - popup gÃ¶ster
                                const message = document.getElementById('popupMessage');
                                const btnText = document.getElementById('popupBtnText');
                                message.textContent = 'Bu bÃ¶lÃ¼m tamamlandÄ±! Devam edin.';
                                btnText.textContent = 'Devam Et';
                                popup.style.display = 'block';
                            }
                        } else {
                            // Son segment veya tek kat modu
                            popup.style.display = 'block';
                        }
                    } else {
                        requestAnimationFrame(monitorAnimation);
                    }
                };

                requestAnimationFrame(monitorAnimation);

            } else {
                const clockwise = (directionToTurn - direction + 360) % 360;
                const counterclockwise = (direction - directionToTurn + 360) % 360;

                if (clockwise <= counterclockwise) {
                    leftArrow.classList.add('fade-out');
                    upArrow.classList.remove('fade-in');
                    upPerspectiveArrow.classList.remove('fade-in');
                    rightArrow.classList.add('fade-in');
                } else {
                    leftArrow.classList.add('fade-in');
                    upArrow.classList.remove('fade-in');
                    upPerspectiveArrow.classList.remove('fade-in');
                    rightArrow.classList.add('fade-out');
                }
                directionMatches = false;
                container.classList.remove('grow');
                progressCircle.style.strokeDashoffset = '283';
            }
        }

        function startCompassListener(callback) {
            if (!window.DeviceOrientationEvent) {
                console.warn("DeviceOrientation API not available");
                return;
            }
            
            if (compassListeners.absolute) {
                window.removeEventListener("deviceorientationabsolute", compassListeners.absolute);
            }
            if (compassListeners.webkit) {
                window.removeEventListener("deviceorientation", compassListeners.webkit);
            }
            
            compassListeners.absolute = (e) => {
                if (!e.absolute || e.alpha == null || e.beta == null || e.gamma == null) return;
                let compass = -(e.alpha + e.beta * e.gamma / 90);
                compass -= Math.floor(compass / 360) * 360;
                callback(compass, e.beta);
            };

            compassListeners.webkit = (e) => {
                let compass = e.webkitCompassHeading;
                if (compass != null && !isNaN(compass)) {
                    callback(compass, e.beta);
                }
            };

            function addListeners() {
                window.addEventListener("deviceorientationabsolute", compassListeners.absolute);
                window.addEventListener("deviceorientation", compassListeners.webkit);
            }

            if (typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === "granted") addListeners();
                    })
                    .catch(console.error);
            } else {
                addListeners();
            }
        }
    </script>
</body>

</html>
