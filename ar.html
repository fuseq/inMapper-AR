<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AR Navigation</title>
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://raw.githack.com/jeromeetienne/AR.js/master/aframe/build/aframe-ar.min.js"></script>
    <script src="https://raw.githack.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
    <script>
        THREEx.ArToolkitContext.baseURL = 'https://raw.githack.com/jeromeetienne/ar.js/master/three.js/'
    </script>
    <script src="./map-direction.js"></script>
    <!-- Modern AR Styles -->
    <link rel="stylesheet" type="text/css" href="./ar-styles.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root { --font-main: 'Inter', sans-serif; }
    </style>
</head>

<body>
    <!-- ============================================
         TOP DIRECTION BAR
         ============================================ -->
    <div class="ar-top-bar" id="arTopBar">
        <div class="direction-card">
            <div class="direction-icon">
                <i class="fas fa-location-arrow"></i>
            </div>
            <div class="direction-info">
                <span class="direction-label">Hedef Yön</span>
                <span class="direction-value" id="directionValue">Kuzey</span>
                <span class="direction-angle" id="directionAngle">0°</span>
            </div>
        </div>
    </div>

    <!-- ============================================
         COMPASS INDICATOR
         ============================================ -->
    <div class="ar-compass" id="arCompass">
        <div class="ar-compass-needle" id="compassNeedle"></div>
    </div>

    <!-- ============================================
         NAVIGATION ARROWS (SVG Based)
         ============================================ -->
    <div class="ar-arrows-container" id="arrowsContainer">
        <!-- Left Arrow -->
        <div class="ar-arrow ar-arrow-left" id="arrowLeft">
            <svg class="arrow-svg" viewBox="0 0 100 100">
                <defs>
                    <linearGradient id="arrowGradientLeft" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#00D4FF;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#7B2FFF;stop-opacity:1" />
                    </linearGradient>
                    <filter id="glowLeft" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
                <path class="arrow-path" fill="url(#arrowGradientLeft)" filter="url(#glowLeft)"
                    d="M70 20 L30 50 L70 80 L70 60 L85 60 L85 40 L70 40 Z"/>
            </svg>
        </div>

        <!-- Right Arrow -->
        <div class="ar-arrow ar-arrow-right" id="arrowRight">
            <svg class="arrow-svg" viewBox="0 0 100 100">
                <defs>
                    <linearGradient id="arrowGradientRight" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:#7B2FFF;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#00D4FF;stop-opacity:1" />
                    </linearGradient>
                    <filter id="glowRight" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
                <path class="arrow-path" fill="url(#arrowGradientRight)" filter="url(#glowRight)"
                    d="M30 20 L70 50 L30 80 L30 60 L15 60 L15 40 L30 40 Z"/>
            </svg>
        </div>

        <!-- Forward Arrow -->
        <div class="ar-arrow ar-arrow-forward" id="arrowForward">
            <svg class="arrow-svg-large" viewBox="0 0 100 100">
                <defs>
                    <linearGradient id="arrowGradientForward" x1="0%" y1="100%" x2="0%" y2="0%">
                        <stop offset="0%" style="stop-color:#00FF88;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#00D4FF;stop-opacity:1" />
                    </linearGradient>
                    <filter id="glowForward" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="6" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
                <path class="arrow-path-success" fill="url(#arrowGradientForward)" filter="url(#glowForward)"
                    d="M50 10 L80 50 L60 50 L60 90 L40 90 L40 50 L20 50 Z"/>
            </svg>
        </div>
    </div>

    <!-- ============================================
         PROGRESS RING
         ============================================ -->
    <div class="ar-progress-container" id="progressContainer">
        <div class="progress-ring">
            <svg viewBox="0 0 180 180">
                <defs>
                    <linearGradient id="progressGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#00FF88"/>
                        <stop offset="100%" style="stop-color:#00D4FF"/>
                    </linearGradient>
                </defs>
                <circle class="progress-ring-bg" cx="90" cy="90" r="80"/>
                <circle class="progress-ring-fill" id="progressRing" cx="90" cy="90" r="80"/>
            </svg>
            <div class="progress-center">
                <div class="progress-icon">✓</div>
                <div class="progress-text">Doğru Yön</div>
            </div>
        </div>
    </div>

    <!-- ============================================
         BOTTOM PANEL
         ============================================ -->
    <div class="ar-bottom-panel map-mode" id="bottomPanel">
        <!-- Map Container -->
        <div class="ar-map-container" id="mapContainer">
            <div id="svgContainer" style="width: 100%; height: 100%; overflow: hidden; position: relative;">
                <div id="svgWrapper" style="transform-origin: 0 0; cursor: grab;">
                    <!-- SVG buraya yüklenecek -->
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="ar-action-bar" id="actionBar">
            <button class="ar-btn ar-btn-primary" id="btnStartAR">
                <svg class="ar-btn-icon" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
                AR Navigasyonu Başlat
            </button>
            <button class="ar-btn ar-btn-danger hidden" id="btnStopAR">
                <i class="fas fa-stop"></i>
                Durdur
            </button>
        </div>

        <!-- Info Bar -->
        <div class="ar-info-bar">
            <div class="ar-destination">
                <div class="ar-destination-icon">
                    <i class="fas fa-flag-checkered"></i>
                </div>
                <div class="ar-destination-info">
                    <h3 id="destinationName">Hedef</h3>
                    <p>
                        <i class="fas fa-route"></i>
                        <span id="directionText">Yükleniyor...</span>
                    </p>
                </div>
            </div>
            <div class="ar-quick-actions">
                <button class="ar-icon-btn" title="Yardım">
                    <i class="fas fa-question"></i>
                </button>
                <button class="ar-icon-btn" id="btnClose" title="Kapat">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- ============================================
         SUCCESS POPUP
         ============================================ -->
    <div class="ar-success-popup" id="successPopup">
        <div class="ar-success-content">
            <div class="ar-success-icon">
                <i class="fas fa-check"></i>
            </div>
            <h2>Harika!</h2>
            <p>Doğru yöne bakıyorsunuz. Şimdi bu yönde ilerlemeye devam edin.</p>
            <button class="ar-success-btn" id="btnOk">
                <i class="fas fa-map"></i>
                Haritaya Dön
            </button>
        </div>
    </div>

    <script>
        // URL'den parametreleri al
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                angle: parseFloat(params.get('angle')) || 0,
                compass: params.get('compass') || 'Kuzey',
                startX: parseFloat(params.get('startX')) || 0,
                startY: parseFloat(params.get('startY')) || 0,
                dirX: parseFloat(params.get('dirX')) || 0,
                dirY: parseFloat(params.get('dirY')) || 1,
                startRoom: params.get('startRoom') || '',
                endRoom: params.get('endRoom') || ''
            };
        }
        
        const targetParams = getQueryParams();
        const directionToTurn = targetParams.angle;
        
        console.log('Hedef açı:', directionToTurn);
        console.log('Hedef yön:', targetParams.compass);
        console.log('Başlangıç:', targetParams.startX, targetParams.startY);
        console.log('Yön vektörü:', targetParams.dirX, targetParams.dirY);
        
        // UI güncelle - Modern
        document.getElementById('directionText').textContent = targetParams.compass + ' yönüne dönün';
        document.getElementById('directionValue').textContent = targetParams.compass;
        document.getElementById('directionAngle').textContent = Math.round(targetParams.angle) + '°';
        document.getElementById('destinationName').textContent = targetParams.endRoom || 'Hedef';
        
        // ==================== SVG HARİTA YÖNETİMİ ====================
        let svgElement = null;
        let scale = 1;
        let panX = 0, panY = 0;
        let isPanning = false;
        let startPanX, startPanY;
        
        // SVG'yi yükle
        async function loadSVG() {
            try {
                let response = await fetch('./sample.svg');
                if (!response.ok) {
                    response = await fetch('../sample.svg');
                }
                if (response.ok) {
                    const content = await response.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(content, 'image/svg+xml');
                    svgElement = doc.documentElement.cloneNode(true);
                    
                    // SVG boyutlarını ayarla
                    svgElement.style.width = '100%';
                    svgElement.style.height = '100%';
                    svgElement.removeAttribute('width');
                    svgElement.removeAttribute('height');
                    
                    // viewBox'ı transform sonrası gerçek içeriğe göre ayarla
                    // Transform: translate(-155.17664,-527.47596)
                    // Orijinal içerik: yaklaşık 0-800 x ve 527-1320 y
                    // Transform sonrası: -155 ile 645 x ve 0 ile 793 y
                    svgElement.setAttribute('viewBox', '-20 -20 700 850');
                    
                    // SVG'yi ekle
                    const wrapper = document.getElementById('svgWrapper');
                    wrapper.appendChild(svgElement);
                    
                    // Yön okunu çiz
                    drawDirectionArrow();
                    
                    // Kullanılan path'leri highlight et
                    highlightUsedPaths();
                    
                    // Başlangıç noktasına odaklan
                    centerOnPoint(targetParams.startX, targetParams.startY);
                    
                    // Zoom/Pan olaylarını ekle
                    setupZoomPan();
                    
                    console.log('SVG yüklendi');
                }
            } catch (e) {
                console.error('SVG yüklenemedi:', e);
            }
        }
        
        // Kullanılan path'leri highlight et
        async function highlightUsedPaths() {
            if (!svgElement) return;
            
            const ns = 'http://www.w3.org/2000/svg';
            
            // MapDirection ile path'i tekrar hesapla
            const mapDir = new MapDirection();
            
            // SVG içeriğini MapDirection'a yükle
            const svgContent = new XMLSerializer().serializeToString(svgElement);
            mapDir.loadSVG(svgContent);
            
            // Path'i bul
            const startRoom = mapDir.rooms.find(r => r.id === targetParams.startRoom);
            const endRoom = mapDir.rooms.find(r => r.id === targetParams.endRoom);
            
            if (!startRoom || !endRoom) {
                console.log('Odalar bulunamadı:', targetParams.startRoom, targetParams.endRoom);
                return;
            }
            
            const startDoor = mapDir.findDoorForRoom(targetParams.startRoom);
            const endDoor = mapDir.findDoorForRoom(targetParams.endRoom);
            
            const startPoint = startDoor ? startDoor.center : startRoom.center;
            const endPoint = endDoor ? endDoor.center : endRoom.center;
            
            const pathResult = mapDir.findPathBetweenPoints(startPoint, endPoint);
            
            if (!pathResult || pathResult.length < 2) {
                console.log('Path bulunamadı');
                return;
            }
            
            console.log('Highlight edilecek path noktaları:', pathResult.length);
            
            // SVG'deki Paths grubunu bul ve görünür yap
            const pathsGroup = svgElement.querySelector('g[id="Paths"]') || 
                               svgElement.querySelector('g[inkscape\\:label="Paths"]');
            
            if (pathsGroup) {
                pathsGroup.style.display = 'block';
                pathsGroup.style.visibility = 'visible';
                pathsGroup.style.opacity = '0.3';
            }
            
            // Transform'u al
            const roomsGroup = svgElement.querySelector('g[id="Rooms"]') || 
                               svgElement.querySelector('g[inkscape\\:label="Rooms"]');
            let groupTransform = '';
            if (roomsGroup) {
                groupTransform = roomsGroup.getAttribute('transform') || '';
            }
            
            // Highlight grubu oluştur
            const highlightGroup = document.createElementNS(ns, 'g');
            highlightGroup.setAttribute('id', 'path-highlight-group');
            if (groupTransform) {
                highlightGroup.setAttribute('transform', groupTransform);
            }
            
            // Tüm path'i mavi çizgi olarak çiz
            for (let i = 0; i < pathResult.length - 1; i++) {
                const p1 = pathResult[i];
                const p2 = pathResult[i + 1];
                
                const line = document.createElementNS(ns, 'line');
                line.setAttribute('x1', p1[0]);
                line.setAttribute('y1', p1[1]);
                line.setAttribute('x2', p2[0]);
                line.setAttribute('y2', p2[1]);
                line.setAttribute('stroke', '#0066ff');
                line.setAttribute('stroke-width', '4');
                line.setAttribute('stroke-linecap', 'round');
                line.setAttribute('opacity', '0.7');
                highlightGroup.appendChild(line);
            }
            
            // İlk 5 segmenti (yön hesaplamasında kullanılanları) sarı ile vurgula
            const pathWithDoor = [startPoint, ...pathResult];
            for (let i = 0; i < Math.min(5, pathWithDoor.length - 1); i++) {
                const p1 = pathWithDoor[i];
                const p2 = pathWithDoor[i + 1];
                
                const line = document.createElementNS(ns, 'line');
                line.setAttribute('x1', p1[0]);
                line.setAttribute('y1', p1[1]);
                line.setAttribute('x2', p2[0]);
                line.setAttribute('y2', p2[1]);
                line.setAttribute('stroke', '#ffff00');
                line.setAttribute('stroke-width', '6');
                line.setAttribute('stroke-linecap', 'round');
                highlightGroup.appendChild(line);
                
                // Segment numarası
                const midX = (p1[0] + p2[0]) / 2;
                const midY = (p1[1] + p2[1]) / 2;
                const text = document.createElementNS(ns, 'text');
                text.setAttribute('x', midX);
                text.setAttribute('y', midY - 5);
                text.setAttribute('fill', '#ff0000');
                text.setAttribute('font-size', '12');
                text.setAttribute('font-weight', 'bold');
                text.textContent = `S${i + 1}`;
                highlightGroup.appendChild(text);
            }
            
            // Path noktalarını daire ile işaretle (ilk 6 nokta = 5 segment)
            pathWithDoor.slice(0, 6).forEach((p, idx) => {
                const circle = document.createElementNS(ns, 'circle');
                circle.setAttribute('cx', p[0]);
                circle.setAttribute('cy', p[1]);
                circle.setAttribute('r', idx === 0 ? '8' : '5');
                circle.setAttribute('fill', idx === 0 ? '#ff0000' : '#ffff00');
                circle.setAttribute('stroke', '#000');
                circle.setAttribute('stroke-width', '1');
                highlightGroup.appendChild(circle);
            });
            
            svgElement.appendChild(highlightGroup);
            console.log('Path highlight edildi');
        }
        
        // Yön okunu çiz
        function drawDirectionArrow() {
            if (!svgElement) {
                console.error('SVG element bulunamadı');
                return;
            }
            
            const ns = 'http://www.w3.org/2000/svg';
            
            // Eski oku sil
            const oldArrow = svgElement.querySelector('#direction-arrow-group');
            if (oldArrow) oldArrow.remove();
            
            // SVG'deki grupların transform'unu al (Rooms veya Paths grubundan)
            const roomsGroup = svgElement.querySelector('g[id="Rooms"]') || 
                               svgElement.querySelector('g[inkscape\\:label="Rooms"]');
            let groupTransform = '';
            if (roomsGroup) {
                groupTransform = roomsGroup.getAttribute('transform') || '';
            }
            
            const group = document.createElementNS(ns, 'g');
            group.setAttribute('id', 'direction-arrow-group');
            // Aynı transform'u oka da uygula
            if (groupTransform) {
                group.setAttribute('transform', groupTransform);
            }
            
            const startX = targetParams.startX;
            const startY = targetParams.startY;
            const arrowLength = 80;
            const endX = startX + targetParams.dirX * arrowLength;
            const endY = startY + targetParams.dirY * arrowLength;
            
            console.log('Ok çiziliyor:', startX, startY, '->', endX, endY);
            console.log('Transform:', groupTransform);
            
            // Glow efekti için filtre
            const defs = document.createElementNS(ns, 'defs');
            const filter = document.createElementNS(ns, 'filter');
            filter.setAttribute('id', 'glow');
            filter.setAttribute('x', '-50%');
            filter.setAttribute('y', '-50%');
            filter.setAttribute('width', '200%');
            filter.setAttribute('height', '200%');
            
            const feGaussianBlur = document.createElementNS(ns, 'feGaussianBlur');
            feGaussianBlur.setAttribute('stdDeviation', '4');
            feGaussianBlur.setAttribute('result', 'coloredBlur');
            filter.appendChild(feGaussianBlur);
            
            const feMerge = document.createElementNS(ns, 'feMerge');
            const feMergeNode1 = document.createElementNS(ns, 'feMergeNode');
            feMergeNode1.setAttribute('in', 'coloredBlur');
            const feMergeNode2 = document.createElementNS(ns, 'feMergeNode');
            feMergeNode2.setAttribute('in', 'SourceGraphic');
            feMerge.appendChild(feMergeNode1);
            feMerge.appendChild(feMergeNode2);
            filter.appendChild(feMerge);
            defs.appendChild(filter);
            group.appendChild(defs);
            
            // Ok çizgisi - kalın ve parlak
            const line = document.createElementNS(ns, 'line');
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', '#00FF00');
            line.setAttribute('stroke-width', '8');
            line.setAttribute('stroke-linecap', 'round');
            line.setAttribute('filter', 'url(#glow)');
            group.appendChild(line);
            
            // Ok ucu (polygon) - daha büyük
            const angle = Math.atan2(targetParams.dirY, targetParams.dirX);
            const headLen = 25;
            const headAngle = Math.PI / 5;
            
            const hx1 = endX - headLen * Math.cos(angle - headAngle);
            const hy1 = endY - headLen * Math.sin(angle - headAngle);
            const hx2 = endX - headLen * Math.cos(angle + headAngle);
            const hy2 = endY - headLen * Math.sin(angle + headAngle);
            
            const head = document.createElementNS(ns, 'polygon');
            head.setAttribute('points', `${endX},${endY} ${hx1},${hy1} ${hx2},${hy2}`);
            head.setAttribute('fill', '#00FF00');
            head.setAttribute('filter', 'url(#glow)');
            group.appendChild(head);
            
            // Başlangıç noktası (daire) - daha büyük ve parlak
            const circle = document.createElementNS(ns, 'circle');
            circle.setAttribute('cx', startX);
            circle.setAttribute('cy', startY);
            circle.setAttribute('r', '15');
            circle.setAttribute('fill', '#FF0000');
            circle.setAttribute('stroke', '#FFFFFF');
            circle.setAttribute('stroke-width', '4');
            circle.setAttribute('filter', 'url(#glow)');
            group.appendChild(circle);
            
            // İç daire (pulse animasyonu için)
            const innerCircle = document.createElementNS(ns, 'circle');
            innerCircle.setAttribute('cx', startX);
            innerCircle.setAttribute('cy', startY);
            innerCircle.setAttribute('r', '8');
            innerCircle.setAttribute('fill', '#FFFFFF');
            group.appendChild(innerCircle);
            
            svgElement.appendChild(group);
            console.log('Ok eklendi');
        }
        
        // Belirli noktaya odaklan
        function centerOnPoint(x, y) {
            const container = document.getElementById('svgContainer');
            const wrapper = document.getElementById('svgWrapper');
            
            if (!svgElement) return;
            
            // Container boyutları
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // SVG boyutları (viewBox'tan bağımsız, render edilmiş boyut)
            const svgRect = svgElement.getBoundingClientRect();
            
            // Transform: translate(-155.17664,-527.47596)
            const translateX = -155.17664;
            const translateY = -527.47596;
            
            // Transform sonrası koordinatlar
            const transformedX = x + translateX;
            const transformedY = y + translateY;
            
            // Tüm haritayı gösterecek başlangıç scale
            scale = 0.8;
            
            // viewBox: -20 -20 700 850 kullanarak
            const vbX = -20, vbY = -20, vbWidth = 700, vbHeight = 850;
            
            // SVG koordinatlarını wrapper koordinatlarına çevir
            const svgScale = Math.min(svgRect.width / vbWidth, svgRect.height / vbHeight);
            const pointX = (transformedX - vbX) * svgScale * scale;
            const pointY = (transformedY - vbY) * svgScale * scale;
            
            // Merkeze al
            panX = containerWidth / 2 - pointX;
            panY = containerHeight / 2 - pointY;
            
            console.log(`centerOnPoint: (${x}, ${y}) -> transform(${transformedX.toFixed(2)}, ${transformedY.toFixed(2)})`);
            
            updateTransform();
        }
        
        // Transform güncelle
        function updateTransform() {
            const wrapper = document.getElementById('svgWrapper');
            wrapper.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
        }
        
        // Zoom/Pan kurulumu
        function setupZoomPan() {
            const container = document.getElementById('svgContainer');
            
            // Mouse wheel zoom
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Zoom merkezi mouse pozisyonu
                const newScale = scale * delta;
                if (newScale < 0.1 || newScale > 10) return;
                
                panX = mouseX - (mouseX - panX) * delta;
                panY = mouseY - (mouseY - panY) * delta;
                scale = newScale;
                
                updateTransform();
            });
            
            // Pan (sürükleme)
            container.addEventListener('mousedown', (e) => {
                isPanning = true;
                startPanX = e.clientX - panX;
                startPanY = e.clientY - panY;
                container.style.cursor = 'grabbing';
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                panX = e.clientX - startPanX;
                panY = e.clientY - startPanY;
                updateTransform();
            });
            
            container.addEventListener('mouseup', () => {
                isPanning = false;
                container.style.cursor = 'grab';
            });
            
            container.addEventListener('mouseleave', () => {
                isPanning = false;
                container.style.cursor = 'grab';
            });
            
            // Touch desteği
            let lastTouchDist = 0;
            let lastTouchX = 0, lastTouchY = 0;
            
            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    isPanning = true;
                    startPanX = e.touches[0].clientX - panX;
                    startPanY = e.touches[0].clientY - panY;
                } else if (e.touches.length === 2) {
                    lastTouchDist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            });
            
            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && isPanning) {
                    panX = e.touches[0].clientX - startPanX;
                    panY = e.touches[0].clientY - startPanY;
                    updateTransform();
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const delta = dist / lastTouchDist;
                    scale *= delta;
                    if (scale < 0.1) scale = 0.1;
                    if (scale > 10) scale = 10;
                    lastTouchDist = dist;
                    updateTransform();
                }
            });
            
            container.addEventListener('touchend', () => {
                isPanning = false;
            });
        }
        
        // Sayfa yüklendiğinde SVG'yi yükle
        document.addEventListener('DOMContentLoaded', loadSVG);
        
        let directionMatches = false;
        let isLoading = false;
        let activeAScene = null;
        let compassListeners = { absolute: null, webkit: null };
        let currentCompassAngle = 0;

        document.addEventListener('DOMContentLoaded', function () {
            // Modern UI Elements
            const btnStartAR = document.getElementById('btnStartAR');
            const btnStopAR = document.getElementById('btnStopAR');
            const btnOk = document.getElementById('btnOk');
            const btnClose = document.getElementById('btnClose');
            const bottomPanel = document.getElementById('bottomPanel');
            const arTopBar = document.getElementById('arTopBar');
            const arCompass = document.getElementById('arCompass');
            const successPopup = document.getElementById('successPopup');

            // Start AR
            btnStartAR.addEventListener('click', function () {
                startARMode();
            });

            // Stop AR
            btnStopAR.addEventListener('click', function () {
                stopARMode();
            });

            // OK Button (Success Popup)
            btnOk.addEventListener('click', function () {
                stopARMode();
            });

            // Close Button
            btnClose.addEventListener('click', function () {
                window.history.back();
            });
        });

        function startARMode() {
            const bottomPanel = document.getElementById('bottomPanel');
            const btnStartAR = document.getElementById('btnStartAR');
            const btnStopAR = document.getElementById('btnStopAR');
            const arTopBar = document.getElementById('arTopBar');
            const arCompass = document.getElementById('arCompass');

            // Create A-Scene
            activeAScene = document.createElement('a-scene');
            activeAScene.setAttribute('vr-mode-ui', 'enabled: false');
            activeAScene.setAttribute('embedded', '');
            activeAScene.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;';
            document.body.insertBefore(activeAScene, document.body.firstChild);

            // UI Updates
            bottomPanel.classList.remove('map-mode');
            bottomPanel.classList.add('ar-mode');
            btnStartAR.classList.add('hidden');
            btnStopAR.classList.remove('hidden');
            arTopBar.classList.add('visible');
            arCompass.classList.add('visible');

            // Start compass listening
            startCompassListener((compass, beta) => {
                currentCompassAngle = compass;
                updateCompassNeedle(compass);
                showArrow(directionToTurn, compass, beta);
            });
        }

        function stopARMode() {
            const bottomPanel = document.getElementById('bottomPanel');
            const btnStartAR = document.getElementById('btnStartAR');
            const btnStopAR = document.getElementById('btnStopAR');
            const arTopBar = document.getElementById('arTopBar');
            const arCompass = document.getElementById('arCompass');
            const successPopup = document.getElementById('successPopup');
            const progressContainer = document.getElementById('progressContainer');

            // Stop compass listeners
            if (compassListeners.absolute) {
                window.removeEventListener("deviceorientationabsolute", compassListeners.absolute);
                compassListeners.absolute = null;
            }
            if (compassListeners.webkit) {
                window.removeEventListener("deviceorientation", compassListeners.webkit);
                compassListeners.webkit = null;
            }

            // Remove A-Scene
            if (activeAScene) {
                activeAScene.remove();
                activeAScene = null;
            }

            // UI Updates
            bottomPanel.classList.remove('ar-mode');
            bottomPanel.classList.add('map-mode');
            btnStartAR.classList.remove('hidden');
            btnStopAR.classList.add('hidden');
            arTopBar.classList.remove('visible');
            arCompass.classList.remove('visible');
            successPopup.classList.remove('visible');
            progressContainer.classList.remove('active');

            // Reset progress
            const progressRing = document.getElementById('progressRing');
            if (progressRing) {
                progressRing.classList.remove('animating');
            }

            // Hide all arrows
            hideAllArrows();

            console.log('AR mode stopped');
        }

        function updateCompassNeedle(angle) {
            const needle = document.getElementById('compassNeedle');
            if (needle) {
                needle.style.transform = `rotate(${angle}deg)`;
            }
        }

        function hideAllArrows() {
            document.getElementById('arrowLeft').classList.remove('visible');
            document.getElementById('arrowRight').classList.remove('visible');
            document.getElementById('arrowForward').classList.remove('visible');
        }

        // Modern Arrow Display Function
        function showArrow(directionToTurn, direction, beta) {
            const arScene = document.querySelector('a-scene');
            if (!arScene) return;

            const arrowLeft = document.getElementById('arrowLeft');
            const arrowRight = document.getElementById('arrowRight');
            const arrowForward = document.getElementById('arrowForward');
            const progressContainer = document.getElementById('progressContainer');
            const progressRing = document.getElementById('progressRing');
            const successPopup = document.getElementById('successPopup');

            const upperBound = (directionToTurn + 20) % 360;
            const lowerBound = (directionToTurn - 20 + 360) % 360;

            // Check if direction is correct (±20 degrees)
            const isCorrectDirection = (direction <= upperBound && direction >= lowerBound) ||
                (lowerBound > upperBound && (direction >= lowerBound || direction <= upperBound));

            if (isCorrectDirection) {
                // Correct direction - show forward arrow and progress
                arrowLeft.classList.remove('visible');
                arrowRight.classList.remove('visible');
                arrowForward.classList.add('visible');
                progressContainer.classList.add('active');
                
                if (!directionMatches) {
                    // Start progress animation
                    progressRing.classList.add('animating');
                    directionMatches = true;

                    // Monitor animation completion
                    const checkCompletion = () => {
                        const computedStyle = getComputedStyle(progressRing);
                        const offset = parseFloat(computedStyle.strokeDashoffset);

                        if (offset <= 1) {
                            console.log('Navigation complete!');
                            
                            // Show success popup
                            successPopup.classList.add('visible');
                            
                            // Stop compass listeners
                            if (compassListeners.absolute) {
                                window.removeEventListener("deviceorientationabsolute", compassListeners.absolute);
                                compassListeners.absolute = null;
                            }
                            if (compassListeners.webkit) {
                                window.removeEventListener("deviceorientation", compassListeners.webkit);
                                compassListeners.webkit = null;
                            }

                            // Hide arrows
                            hideAllArrows();
                        } else if (directionMatches) {
                            requestAnimationFrame(checkCompletion);
                        }
                    };

                    requestAnimationFrame(checkCompletion);
                }

            } else {
                // Wrong direction - show turn arrows
                arrowForward.classList.remove('visible');
                progressContainer.classList.remove('active');
                
                // Reset progress if direction changed
                if (directionMatches) {
                    progressRing.classList.remove('animating');
                    directionMatches = false;
                }

                // Calculate shortest turn direction
                const clockwise = (directionToTurn - direction + 360) % 360;
                const counterclockwise = (direction - directionToTurn + 360) % 360;

                if (clockwise <= counterclockwise) {
                    // Turn right
                    arrowLeft.classList.remove('visible');
                    arrowRight.classList.add('visible');
                } else {
                    // Turn left
                    arrowRight.classList.remove('visible');
                    arrowLeft.classList.add('visible');
                }
            }
        }

        function startCompassListener(callback) {
            if (!window.DeviceOrientationEvent) {
                console.warn("DeviceOrientation API not available");
                return;
            }
            
            // Önceki listener'ları temizle
            if (compassListeners.absolute) {
                window.removeEventListener("deviceorientationabsolute", compassListeners.absolute);
            }
            if (compassListeners.webkit) {
                window.removeEventListener("deviceorientation", compassListeners.webkit);
            }
            
            compassListeners.absolute = (e) => {
                if (!e.absolute || e.alpha == null || e.beta == null || e.gamma == null) {
                    return;
                }
                let compass = -(e.alpha + e.beta * e.gamma / 90);
                compass -= Math.floor(compass / 360) * 360;
                callback(compass, e.beta);
            };

            compassListeners.webkit = (e) => {
                let compass = e.webkitCompassHeading;
                if (compass != null && !isNaN(compass)) {
                    callback(compass, e.beta);
                }
            };

            function addListeners() {
                window.addEventListener("deviceorientationabsolute", compassListeners.absolute);
                window.addEventListener("deviceorientation", compassListeners.webkit);
            }

            if (typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === "granted") {
                            addListeners();
                        } else {
                            console.warn("Permission for DeviceOrientationEvent not granted");
                        }
                    })
                    .catch(error => {
                        console.error("Error requesting permission:", error);
                    });
            } else {
                addListeners();
            }
        }
    </script>
</body>

</html>
